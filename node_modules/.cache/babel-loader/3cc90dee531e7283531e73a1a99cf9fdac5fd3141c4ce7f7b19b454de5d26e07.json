{"ast":null,"code":"import { useState, useRef, useCallback } from 'react';\nimport { useFreshCallback } from './useFreshCallback.js';\nimport { useTimeoutWhen } from './useTimeoutWhen.js';\n\n/**\r\n * useDebounceFn\r\n * @description Powerful debounce function hook for React\r\n * @see {@link https://rooks.vercel.app/docs/useDebounceFn}\r\n */\nfunction useDebounceFn(func, delay) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n    leading: false,\n    trailing: true\n  };\n  const {\n    leading,\n    trailing,\n    maxWait\n  } = options;\n  if (!leading && !trailing) {\n    throw new Error(\"leading and trailing cannot both be false\");\n  } else if (typeof maxWait !== \"undefined\" && maxWait < delay) {\n    throw new Error(\"maxWait cannot be less than delay\");\n  }\n  const funcRef = useFreshCallback(func);\n  const [isTimeoutEnabled, setIsTimeoutEnabled] = useState(false);\n  // we use key to reset a timeout when the key changes\n  const [key, setKey] = useState(0);\n  const lastExecutionTimeRef = useRef(0);\n  const argsRef = useRef();\n  const debouncedFn = useCallback(function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    argsRef.current = args;\n    const overrideTimeout = typeof maxWait !== \"undefined\" && lastExecutionTimeRef.current && Date.now() - lastExecutionTimeRef.current > maxWait;\n    // If the leading edge is enabled, we should call the function\n    // immediately\n    // if timeout is not enabled, we should call the function\n    if (leading) {\n      if (isTimeoutEnabled && overrideTimeout) {\n        // reset the timeout\n        setKey(prevKey => prevKey + 1);\n        lastExecutionTimeRef.current = Date.now();\n        try {\n          funcRef(...args);\n        } catch (error) {\n          console.warn(error);\n        }\n      } else if (overrideTimeout && !isTimeoutEnabled) {\n        setIsTimeoutEnabled(true);\n        lastExecutionTimeRef.current = Date.now();\n        try {\n          funcRef(...args);\n        } catch (error) {\n          console.warn(error);\n        }\n      } else if (isTimeoutEnabled && !overrideTimeout) ;else {\n        // !isTimeoutEnabled && !overrideTimeout\n        setIsTimeoutEnabled(true);\n        lastExecutionTimeRef.current = Date.now();\n        try {\n          funcRef(...args);\n        } catch (error) {\n          console.warn(error);\n        }\n      }\n    }\n    if (trailing) {\n      // trailing scenarios\n      if (isTimeoutEnabled) {\n        // reset the timeout\n        setKey(prevKey => prevKey + 1);\n      } else {\n        // set the timeout\n        setIsTimeoutEnabled(true);\n      }\n    }\n  }, [maxWait, isTimeoutEnabled, leading, trailing, funcRef]);\n  // if timeout is enabled, is trailing and maxWait is defined, we should clear the timeout\n  // and call the function\n  useTimeoutWhen(() => {\n    // noop condition but for typechecking\n    if (typeof maxWait !== \"undefined\" && trailing) {\n      if (!argsRef.current) return;\n      lastExecutionTimeRef.current = Date.now();\n      try {\n        funcRef(...argsRef.current);\n      } catch (error) {\n        console.warn(error);\n      }\n    }\n  }, maxWait !== null && maxWait !== void 0 ? maxWait : Infinity, isTimeoutEnabled && typeof maxWait !== \"undefined\" && trailing, key);\n  useTimeoutWhen(() => {\n    if (trailing) {\n      if (!argsRef.current) return;\n      lastExecutionTimeRef.current = Date.now();\n      try {\n        funcRef(...argsRef.current);\n      } catch (error) {\n        console.warn(error);\n      }\n    }\n    setIsTimeoutEnabled(false);\n  }, delay, isTimeoutEnabled && trailing, key);\n  const freshDebouncedFn = useFreshCallback(debouncedFn);\n  return [freshDebouncedFn, isTimeoutEnabled];\n}\nexport { useDebounceFn };","map":{"version":3,"names":["useState","useRef","useCallback","useFreshCallback","useTimeoutWhen","useDebounceFn","func","delay","options","arguments","length","undefined","leading","trailing","maxWait","Error","funcRef","isTimeoutEnabled","setIsTimeoutEnabled","key","setKey","lastExecutionTimeRef","argsRef","debouncedFn","_len","args","Array","_key","current","overrideTimeout","Date","now","prevKey","error","console","warn","Infinity","freshDebouncedFn"],"sources":["/Users/benjin8or/Cisco Project/cisco-project/node_modules/rooks/dist/esm/hooks/useDebounceFn.js"],"sourcesContent":["import { useState, useRef, useCallback } from 'react';\nimport { useFreshCallback } from './useFreshCallback.js';\nimport { useTimeoutWhen } from './useTimeoutWhen.js';\n\n/**\r\n * useDebounceFn\r\n * @description Powerful debounce function hook for React\r\n * @see {@link https://rooks.vercel.app/docs/useDebounceFn}\r\n */\r\nfunction useDebounceFn(func, delay, options = { leading: false, trailing: true }) {\r\n    const { leading, trailing, maxWait } = options;\r\n    if (!leading && !trailing) {\r\n        throw new Error(\"leading and trailing cannot both be false\");\r\n    }\r\n    else if (typeof maxWait !== \"undefined\" && maxWait < delay) {\r\n        throw new Error(\"maxWait cannot be less than delay\");\r\n    }\r\n    const funcRef = useFreshCallback(func);\r\n    const [isTimeoutEnabled, setIsTimeoutEnabled] = useState(false);\r\n    // we use key to reset a timeout when the key changes\r\n    const [key, setKey] = useState(0);\r\n    const lastExecutionTimeRef = useRef(0);\r\n    const argsRef = useRef();\r\n    const debouncedFn = useCallback((...args) => {\r\n        argsRef.current = args;\r\n        const overrideTimeout = typeof maxWait !== \"undefined\" &&\r\n            lastExecutionTimeRef.current &&\r\n            Date.now() - lastExecutionTimeRef.current > maxWait;\r\n        // If the leading edge is enabled, we should call the function\r\n        // immediately\r\n        // if timeout is not enabled, we should call the function\r\n        if (leading) {\r\n            if (isTimeoutEnabled && overrideTimeout) {\r\n                // reset the timeout\r\n                setKey((prevKey) => prevKey + 1);\r\n                lastExecutionTimeRef.current = Date.now();\r\n                try {\r\n                    funcRef(...args);\r\n                }\r\n                catch (error) {\r\n                    console.warn(error);\r\n                }\r\n            }\r\n            else if (overrideTimeout && !isTimeoutEnabled) {\r\n                setIsTimeoutEnabled(true);\r\n                lastExecutionTimeRef.current = Date.now();\r\n                try {\r\n                    funcRef(...args);\r\n                }\r\n                catch (error) {\r\n                    console.warn(error);\r\n                }\r\n            }\r\n            else if (isTimeoutEnabled && !overrideTimeout) ;\r\n            else {\r\n                // !isTimeoutEnabled && !overrideTimeout\r\n                setIsTimeoutEnabled(true);\r\n                lastExecutionTimeRef.current = Date.now();\r\n                try {\r\n                    funcRef(...args);\r\n                }\r\n                catch (error) {\r\n                    console.warn(error);\r\n                }\r\n            }\r\n        }\r\n        if (trailing) {\r\n            // trailing scenarios\r\n            if (isTimeoutEnabled) {\r\n                // reset the timeout\r\n                setKey((prevKey) => prevKey + 1);\r\n            }\r\n            else {\r\n                // set the timeout\r\n                setIsTimeoutEnabled(true);\r\n            }\r\n        }\r\n    }, [maxWait, isTimeoutEnabled, leading, trailing, funcRef]);\r\n    // if timeout is enabled, is trailing and maxWait is defined, we should clear the timeout\r\n    // and call the function\r\n    useTimeoutWhen(() => {\r\n        // noop condition but for typechecking\r\n        if (typeof maxWait !== \"undefined\" && trailing) {\r\n            if (!argsRef.current)\r\n                return;\r\n            lastExecutionTimeRef.current = Date.now();\r\n            try {\r\n                funcRef(...argsRef.current);\r\n            }\r\n            catch (error) {\r\n                console.warn(error);\r\n            }\r\n        }\r\n    }, maxWait !== null && maxWait !== void 0 ? maxWait : Infinity, isTimeoutEnabled && typeof maxWait !== \"undefined\" && trailing, key);\r\n    useTimeoutWhen(() => {\r\n        if (trailing) {\r\n            if (!argsRef.current)\r\n                return;\r\n            lastExecutionTimeRef.current = Date.now();\r\n            try {\r\n                funcRef(...argsRef.current);\r\n            }\r\n            catch (error) {\r\n                console.warn(error);\r\n            }\r\n        }\r\n        setIsTimeoutEnabled(false);\r\n    }, delay, isTimeoutEnabled && trailing, key);\r\n    const freshDebouncedFn = useFreshCallback(debouncedFn);\r\n    return [freshDebouncedFn, isTimeoutEnabled];\r\n}\n\nexport { useDebounceFn };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}